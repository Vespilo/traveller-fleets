<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
            background-color: #000;
        }

        #controlBar {
            position: absolute;
            color: white
        }

        #selectedShip {
            position: absolute;
            top: 50px;
            left: 10px;
            background-color: white;
            padding: 1em;
            min-width: 10em;
        }

        #contextMenu {
            display: none;
            position: absolute;
            padding: 1em;
            background-color: white;
        }
    </style>
</head>
<body>
<nav id="controlBar">
    <span>Current Player: <span id="currentPlayer"></span></span>
    <span>Current Turn: <span id="currentTurn"></span></span>
    <span>Current Phase: <span id="currentPhase"></span></span>
    <span>Time since start: <span id="timesincestart"></span></span>
    <span>Zoom: <span id="scale"></span></span>
    <button onclick="zoomTo(0, 0, 2)">Reset</button>
    <button onclick="endTurn()">Next Phase</button>
</nav>

<div id="selectedShip">
    Selected: <span id="shipSelected"></span><br>
    Vector: <span id="shipHeading"></span><br>
    Target: <span id="shipTarget"></span><br>
    Velocity: <span id="shipVelocity"></span><br>
    Thrust: <span id="shipThrust"></span><br>

</div>

<div id="contextMenu">
    <button onclick="document.querySelector('#contextMenu').style = `display: none`">Close</button>
    <div class="contextMenu_movement">
        <span id="targetshipname"></span>
        <button onclick="setTarget()">Target</button>
    </div>
</div>

<canvas id="solarSystemCanvas"></canvas>

<script>
    const subPhases = ['Movement', 'Sensors', 'Attacks', 'Damage Control'];


    let needsRedraw = false;
    let needsUIUpdate = false;
    let minutesSinceStart = 0
    let selectedShip
    let targetedPosition
    let running = false
    let players = []
    let currentPlayerIndex = 0;
    let currentSubPhaseIndex = 0;


    function endTurn() {
        let currentPlayer = players[currentPlayerIndex];

        // Perform actions specific to the current sub-phase
        switch (subPhases[currentSubPhaseIndex]) {
            case 'Movement':
                currentPlayer.ships.forEach(ship => {
                    ship.move();
                });
                break;
            case 'Sensors':
                // Add sensor logic here
                break;
            case 'Attacks':
                // Add attack logic here
                break;
            case 'Damage Control':
                // Add damage control logic here
                break;
        }

        // Move to the next player or sub-phase
        currentPlayerIndex++;
        if (currentPlayerIndex >= players.length) {
            currentPlayerIndex = 0;
            currentSubPhaseIndex++;
            if (currentSubPhaseIndex >= subPhases.length) {
                currentSubPhaseIndex = 0;
                console.log('New turn begins.');
            }
        }

        // Update UI for the new player and sub-phase
        needsUIUpdate = true;
        updateUI();
    }

    function gameLoop() {
        window.requestAnimationFrame(gameLoop);
        if (needsRedraw) {
            draw();
            needsRedraw = false;
        }
        if (needsUIUpdate) {
            updateUI();
            needsUIUpdate = false;
        }
    }

    function zoomTo(x, y, scaleSize) {
        scale = scaleSize
        offsetX = (canvas.width / 2) - (x / kmPerPixel * scale)
        offsetY = (canvas.height / 2) - (y / kmPerPixel * scale)
        needsRedraw = true;
    }

    const canvas = document.getElementById('solarSystemCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Initial scale and position
    let scale = 3;
    let offsetX = canvas.width / 2;
    let offsetY = canvas.height / 2;


    // Conversion factor to fit the celestial bodies on the canvas at the initial scale
    const kmPerPixel = 1000000;

    // Celestial bodies data
    const bodies = [
        {name: "Sun", x: 0, y: 0, radius: 696340, color: "yellow"},
        {name: "Mercury", x: 57910000, y: 0, radius: 2439, color: "grey"},
        {name: "Venus", x: 108200000, y: 0, radius: 6051, color: "orange"},
        {name: "Earth", x: 149600000, y: 0, radius: 6371, color: "green"},
        {name: "Mars", x: 227900000, y: 0, radius: 3389, color: "red"},
        {name: "Jupiter", x: 715000000, y: 0, radius: 69911, color: "brown"},
        {name: "Saturn", x: 1433449370, y: 0, radius: 58232, color: "blue"},
        // Add more planets as needed
    ];

    class Util {
        static calculateAngleFromVectors(dx, dy, rounding = 3) {
            /**
             * Returns the angle of two vectors with n decimals
             * @param {number} dx - Delta X
             * @param {number} dy - Delta Y
             * @param {number} rounding - Rounded to n digits
             */
            const angleRadians = Math.atan2(dx, dy);
            const angleDegrees = angleRadians * (180 / Math.PI);
            const x = 10 * rounding
            return Math.round(((angleDegrees + 360) % 360) * x) / x; // Normalize to [0, 360) degrees
        }

        static calculateAngleFromPositions(position_1, position_2, rounding = 3) {
            /**
             * Returns the angle between two positions with n decimals
             * @param {array} position_1 - Position 1
             * @param {array} position_2 - Position 2
             * @param {number} rounding - Rounded to n digits
             */
            const dx = position_2[0] - position_1[0];
            const dy = position_2[1] - position_1[1];
            return Util.calculateAngleFromVectors(dx, dy, rounding);
        }
    }

    class Player {
        constructor(name) {
            this.name = name
            this.ships = []
        }
    }

    class Ship {
        constructor(name, position, thrust, color) {
            this.name = name
            this.position = position
            this.color = color
            this.maxThrust = thrust
            this.heading = 0
            this.vector = [0, 0]
            this.thrust = [0, 0]
            this.targetposition = position
        }


        getCurrentHeading() {
            return Util.calculateAngleFromVectors(this.vector[0], this.vector[1]);
        }


        setThrustFromHeading(angleDegrees) {
            this.heading = angleDegrees;

            // Angle to radians
            const angleRadians = (90 - angleDegrees) * (Math.PI / 180);

            // Calculate thrust angled
            const thrustX = this.maxThrust * Math.cos(angleRadians);
            const thrustY = this.maxThrust * Math.sin(angleRadians);

            // Thrust vector
            const totalThrust = Math.abs(thrustX) + Math.abs(thrustY);
            const factor = this.maxThrust / totalThrust;

            this.thrust = [thrustX * factor, thrustY * factor];
        }

        calculateVector() {
            Util.calculateAngleFromVectors(this.thrust[0], this.thrust[1])
            //console.log([this.vector[0] + this.thrust[0], this.vector[1] + this.thrust[1]])
            return [this.vector[0] + this.thrust[0], this.vector[1] + this.thrust[1]]
        }


        move() {

            this.vector = this.calculateVector()
            this.position[0] += this.vector[0] * 6
            this.position[1] += this.vector[1] * 6

            if (this.targetposition !== this.position) {
                this.setThrustFromHeading(Util.calculateAngleFromPositions(this.position, this.targetposition))
            }
        }
    }

    // Setting Up Default Players
    players = [
        new Player("Player 1"),
        new Player("Player 2")
    ]
    players[0].ships = [
        new Ship("Fleet 1", [(57910000 + 2439 + 600), 0], 6, "blue"),
        new Ship("Fleet 2", [(577910000 + 2439 + 600), -579120], 6, "blue"),
        new Ship("Fleet 3", [(227900000 + 3389 - 600), 60000000], 6, "blue"),
        new Ship("Fleet 4", [(-27900000 + 3389 - 600), 200000], 6, "blue"),
    ]
    players[1].ships = [
        new Ship("Fleet 1", [(579120 + 3389 - 600), -6100000], 6, "red"),
        new Ship("Fleet 2", [(2439 + 3389 - 600), 60000000], 6, "red"),
        new Ship("Fleet 3", [(227900000 + 3389 - 600), -10000000], 6, "red"),
        new Ship("Fleet 4", [(10000000 + 3389 - 600), 12400], 6, "red"),
    ]
    const ships = [...players[0].ships, ...players[1].ships]

    function updateUI() {
        document.querySelector('#scale').textContent = Math.round(scale);
        document.querySelector('#timesincestart').textContent = minutesSinceStart;
        document.querySelector('#currentPlayer').textContent = players[currentPlayerIndex].name;
        document.querySelector('#currentPhase').textContent = subPhases[currentSubPhaseIndex];

        if (selectedShip) {
            document.querySelector('#shipSelected').textContent = selectedShip.name;
            document.querySelector('#shipHeading').textContent = selectedShip.getCurrentHeading() + "°" || "0°";
            document.querySelector('#shipThrust').textContent = "[" + selectedShip.thrust[0].toFixed(2) + ", " + selectedShip.thrust[1].toFixed(2) + "] | " + selectedShip.maxThrust || "[0, 0]";
            document.querySelector('#shipTarget').textContent = `[${Math.round(selectedShip.targetposition[0])}, ${Math.round(selectedShip.targetposition[1])}]`;
            document.querySelector('#shipVelocity').textContent = `[${Math.round(selectedShip.vector[0])}, ${Math.round(selectedShip.vector[1])}]`;
        } else {
            document.querySelector('#shipSelected').textContent = "";
            document.querySelector('#shipHeading').textContent = "0";
            document.querySelector('#shipThrust').textContent = "[0, 0]";
        }
    }


    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        const viewX = -offsetX / scale;
        const viewY = -offsetY / scale;
        const viewWidth = canvas.width / scale;
        const viewHeight = canvas.height / scale;

        // Check if a point (x, y) is within the current view
        function isInView(x, y, radius = 0) {
            return (
                x + radius >= viewX &&
                x - radius <= viewX + viewWidth &&
                y + radius >= viewY &&
                y - radius <= viewY + viewHeight
            );
        }

        // Draw celestial bodies
        bodies.forEach(body => {
            const bodyX = body.x / kmPerPixel;
            const bodyY = body.y / kmPerPixel;
            const bodyRadius = body.radius / kmPerPixel;

            if (isInView(bodyX, bodyY, bodyRadius)) {
                ctx.fillStyle = body.color || 'red';
                ctx.beginPath();
                ctx.arc(bodyX, bodyY, bodyRadius, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.strokeStyle = "white";
            ctx.lineWidth = 0.5 / scale;
            ctx.beginPath();
            ctx.arc(0, 0, bodyX, 0, Math.PI * 2);
            ctx.stroke();
        });

        // Draw ships
        ships.forEach(ship => {
            const shipX = ship.position[0] / kmPerPixel;
            const shipY = ship.position[1] / kmPerPixel;
            const shipWidth = 25 / scale;
            const shipHeight = 25 / scale;

            if (isInView(shipX, shipY, shipWidth / 2)) {
                ctx.fillStyle = ship.color;
                ctx.beginPath();
                ctx.rect(shipX, shipY, shipWidth, shipHeight);
                ctx.fill();
                ctx.font = `${20 / scale}px arial`;
                ctx.fillStyle = "white";
                ctx.fillText(ship.name, Math.ceil(ship.position[0] / kmPerPixel), Math.ceil(ship.position[1] / kmPerPixel));

                // Draw Ghost Lines and Ranges
                ctx.strokeStyle = "white";
                ctx.lineWidth = 2 / scale;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(shipX, shipY);
                ctx.lineTo(ship.targetposition[0] / kmPerPixel, ship.targetposition[1] / kmPerPixel);

                [50000, 25000, 10000, 1250, 10].forEach(range => {
                    const lineDash = range === 10 ? [5 / kmPerPixel, 15 / kmPerPixel] : [500 / kmPerPixel, 1500 / kmPerPixel];
                    ctx.setLineDash(lineDash);
                    ctx.lineWidth = 1 / scale;
                    ctx.beginPath();
                    ctx.arc(shipX, shipY, range / kmPerPixel, 0, Math.PI * 2);
                });
                ctx.stroke();
            }
        });

        ctx.restore();
    }

    function isNearOrbit(mouseX, mouseY) {
        const orbitClickTolerance = 5;
        const canvasX = (mouseX - offsetX) / scale;
        const canvasY = (mouseY - offsetY) / scale;

        for (let i = 0; i < bodies.length; i++) { // Start from 1 to skip the Sun
            const body = bodies[i];
            const distanceToOrbitCenter = Math.sqrt(canvasX * canvasX + canvasY * canvasY);
            const distanceToOrbit = Math.abs(distanceToOrbitCenter - (body.x / kmPerPixel));

            if (distanceToOrbit <= orbitClickTolerance / scale) {
                // Detected a click near this orbit
                console.log(`Clicked near the orbit of ${body.name}`);
                return body;
            }
        }
        return null;
    }

    function isShip(mouseX, mouseY) {
        const canvasX = (mouseX - offsetX) / scale;
        const canvasY = (mouseY - offsetY) / scale;

        for (let i = 0; i < ships.length; i++) {
            const ship = ships[i];

            if ((canvasX >= ship.position[0] / kmPerPixel && canvasX <= ship.position[0] / kmPerPixel + 50 / scale) && (canvasY >= ship.position[1] / kmPerPixel && canvasY <= ship.position[1] / kmPerPixel + 50 / scale)) {
                return ship;
            }
        }
        return null;
    }

    // Event listener for zooming with mouse scroll
    canvas.addEventListener('wheel', (event) => {
        updateUI()
        event.preventDefault();
        const zoomFactor = 1.1;
        const direction = event.deltaY > 0 ? -1 : 1;
        const mouseX = event.clientX - canvas.offsetLeft;
        const mouseY = event.clientY - canvas.offsetTop;

        // Get the position on the canvas relative to the current zoom and offset
        let worldX = (mouseX - offsetX) / scale;
        let worldY = (mouseY - offsetY) / scale;


        // Adjust scale
        const oldScale = scale;
        scale *= direction > 0 ? zoomFactor : 1 / zoomFactor;
        scale = Math.min(Math.max(scale, 1 / 500000), 10000000); // Limit scale between 1km and 500,000km


        if (selectedShip) {
            // Center zoom on selected ship if one is selected
            const shipX = selectedShip.position[0] / kmPerPixel;
            const shipY = selectedShip.position[1] / kmPerPixel;

            offsetX = (canvas.width / 2) - (shipX * scale);
            offsetY = (canvas.height / 2) - (shipY * scale);

        } else {
            // Adjust offsets to maintain zoom center on cursor position
            offsetX -= (worldX * scale - worldX * oldScale);
            offsetY -= (worldY * scale - worldY * oldScale);
        }

        needsRedraw = true;
    });

    // Variables for dragging
    let isDragging = false;
    let dragStartX, dragStartY;

    // Event listeners for dragging
    canvas.addEventListener('mousedown', (event) => {
        isDragging = true;
        dragStartX = event.clientX;
        dragStartY = event.clientY;
    });

    canvas.addEventListener('mousemove', (event) => {
        if (isDragging) {
            offsetX += (event.clientX - dragStartX);
            offsetY += (event.clientY - dragStartY);
            dragStartX = event.clientX;
            dragStartY = event.clientY;
            needsRedraw = true;
        }
    });

    canvas.addEventListener('mouseup', () => {
        isDragging = false;
    });

    canvas.addEventListener('mouseleave', () => {
        isDragging = false;
    });

    function handleClick(mouseX, mouseY, shiftKey) {
        const body = isNearOrbit(mouseX, mouseY);
        const ship = isShip(mouseX, mouseY);

        if (ship) {
            selectedShip = ship;
            console.log(`You clicked near the fleet ${ship.name}.`);
            needsUIUpdate = true;
        } else if (body) {
            zoomTo(body.x, body.y, body.radius * 5);
            console.log(`You clicked near the orbit of ${body.name}.`);
            selectedShip = null;
            needsUIUpdate = true;
        } else {
            selectedShip = null;
            needsUIUpdate = true;
        }


        if (shiftKey && selectedShip) {
            if (!players[currentPlayerIndex].ships.includes(selectedShip)) {
                alert("Enemy ship can't be commanded");
                return;
            }
            const canvasMouseX = (mouseX - offsetX) / scale;
            const canvasMouseY = (mouseY - offsetY) / scale;

            selectedShip.targetposition = [canvasMouseX * kmPerPixel, canvasMouseY * kmPerPixel];
            const heading = Util.calculateAngleFromPositions(selectedShip.position, selectedShip.targetposition);
            selectedShip.setThrustFromHeading(heading);
            needsRedraw = true;
        } else if (ship) {
            zoomTo(ship.position[0], ship.position[1], scale);
            selectedShip = ship;
            console.log(`You clicked near the fleet ${ship.name}.`);
            needsUIUpdate = true;
        } else if (body) {
            zoomTo(body.x, body.y, body.radius * 5);
            console.log(`You clicked near the orbit of ${body.name}.`);
            selectedShip = null;
            needsUIUpdate = true;
        } else {
            selectedShip = null;
            needsUIUpdate = true;
        }
    }


    canvas.addEventListener('click', (event) => {
        document.querySelector('#contextMenu').style = `display: none`

        const mouseX = event.clientX - canvas.offsetLeft;
        const mouseY = event.clientY - canvas.offsetTop;
        handleClick(mouseX, mouseY, event.shiftKey);
    });

    canvas.addEventListener('dblclick', (event) => {
        const mouseX = event.clientX - canvas.offsetLeft;
        const mouseY = event.clientY - canvas.offsetTop;
        const ship = isShip(mouseX, mouseY);


        if (ship) {
            zoomTo(ship.position[0], ship.position[1], 5000)
            // Action when an orbit is clicked
            selectedShip = ship
            console.log(`You clicked near the fleet ${ship.name}.`);
        }

    });

    canvas.addEventListener('contextmenu', function (event) {
        event.preventDefault();
        if (!selectedShip || !players[currentPlayerIndex].ships.includes(selectedShip)) {
            return
        }

        const mouseX = event.clientX - canvas.offsetLeft;
        const mouseY = event.clientY - canvas.offsetTop;
        const ship = isShip(mouseX, mouseY);
        const body = isNearOrbit(mouseX, mouseY);

        const canvasMouseX = (mouseX - offsetX) / scale;
        const canvasMouseY = (mouseY - offsetY) / scale;

        targetedPosition = [canvasMouseX * kmPerPixel, canvasMouseY * kmPerPixel];


        document.querySelector('#contextMenu').style = `top: ${event.clientY}px; left: ${event.clientX}px; display: block`
        const target = document.querySelector('#targetshipname')

        if (ship) {
            target.textContent = ship.name
            targetedPosition = ship.position
        } else if (body) {
            target.textContent = body.name
            targetedPosition = [body.x, body.y]
        } else {
            target.textContent = "Space"
        }
    }, false);

    function setTarget(event) {


        // Action when an orbit is clicked
        selectedShip.targetposition = targetedPosition
        const t = Util.calculateAngleFromPositions(selectedShip.position, selectedShip.targetposition)
        selectedShip.setThrustFromHeading(t)
        console.log(`Setting course to ${targetedPosition}.`);


        cmenu = document.querySelector('#contextMenu')
        cmenu.style = `display: none`
    }

    // Initial drawing
    draw();
    gameLoop()

    // Resize canvas when the window size changes
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        needsRedraw = true;
    });
</script>
</body>
</html>
