<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
            background-color: #000;
        }

        #controlBar {
            position: absolute;
            color: white
        }

        #selectedShip {
            position: absolute;
            top: 50px;
            left: 10px;
            background-color: white;
            padding: 1em;
            min-width: 10em;
        }

        #contextMenu {
            display: none;
            position: absolute;
            padding: 1em;
            background-color: white;
        }
    </style>
</head>
<body>
<nav id="controlBar">
    <span>Time since start: <span id="timesincestart"></span></span>
    <span>Zoom: <span id="scale"></span></span>
    <button onclick="zoomTo(0, 0, 2)">Reset</button>
    <button onclick="pauseGame()">Run</button>
    <button onclick="singleTick()">Tick</button>
</nav>

<div id="selectedShip">
    Selected: <span id="shipSelected"></span><br>
    Vector: <span id="shipHeading"></span><br>
    Thrust: <span id="shipThrust"></span><br>

</div>

<div id="contextMenu">
    <button onclick="setTarget()">Target</button>
</div>

<canvas id="solarSystemCanvas"></canvas>

<script>
    let minutesSinceStart = 0
    let selectedShip
    let targetedPosition
    let running = false

    function pauseGame() {
        running = !running
    }

    function singleTick() {
        for (let i = 0; i < ships.length; i++) {
            const ship = ships[i]
            ship.move()
        }
        draw()

        minutesSinceStart += 6
    }

    function gameLoop() {
        window.requestAnimationFrame(gameLoop);

        tick();
        updateUI()
    }

    function tick() {
        if (running) {
            for (let i = 0; i < ships.length; i++) {
                const ship = ships[i]
                ship.calculateVector()
                ship.move()
            }
            minutesSinceStart += 6
        }
        draw()
    }

    function zoomTo(x, y, scaleSize) {
        scale = scaleSize
        offsetX = (canvas.width / 2) - (x / kmPerPixel * scale)
        offsetY = (canvas.height / 2) - (y / kmPerPixel * scale)
        draw()
    }

    const canvas = document.getElementById('solarSystemCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Initial scale and position
    let scale = 3;
    let offsetX = canvas.width / 2;
    let offsetY = canvas.height / 2;


    // Conversion factor to fit the celestial bodies on the canvas at the initial scale
    const kmPerPixel = 1000000;

    // Celestial bodies data
    const bodies = [
        {name: "Sun", x: 0, y: 0, radius: 696340, color: "yellow"},
        {name: "Mercury", x: 57910000, y: 0, radius: 2439, color: "grey"},
        {name: "Venus", x: 108200000, y: 0, radius: 6051, color: "orange"},
        {name: "Earth", x: 149600000, y: 0, radius: 6371, color: "green"},
        {name: "Mars", x: 227900000, y: 0, radius: 3389, color: "red"},
        {name: "Jupiter", x: 715000000, y: 0, radius: 69911, color: "brown"},
        {name: "Saturn", x: 1433449370, y: 0, radius: 58232, color: "blue"},
        // Add more planets as needed
    ];



    class Ship {
        constructor(name, position, thrust, color) {
            this.name = name
            this.position = position
            this.color = color
            this.maxThrust = thrust
            this.heading = 0
            this.vector = [0, 0]
            this.thrust = [0, 0]
            this.targetposition = position
        }
        static calculateAngle(dx, dy) {
            const angleRadians = Math.atan2(dx, dy);
            const angleDegrees = angleRadians * (180 / Math.PI);
            return Math.round(((angleDegrees + 360) % 360) * 1000) / 1000; // Normalize to [0, 360) degrees
        }

        static calculateCurrentHeading(thrustX, thrustY) {
            return Ship.calculateAngle(thrustX, thrustY);
        }

        getCurrentHeading() {
            return Ship.calculateAngle(this.vector[0], this.vector[1]);
        }

        static calculateHeading(position, target) {
            const dx = target[0] - position[0];
            const dy = target[1] - position[1];
            return Ship.calculateAngle(dx, dy);
        }



        setThrustFromHeading(angleDegrees) {
            this.heading = angleDegrees;

            // Convert angle from degrees to radians
            const angleRadians = (90 - angleDegrees) * (Math.PI / 180);



            // Calculate thrust components
            const thrustX = this.maxThrust * Math.cos(angleRadians);
            const thrustY = this.maxThrust * Math.sin(angleRadians);

            // Compute thrust vector components
            const totalThrust = Math.abs(thrustX) + Math.abs(thrustY);
            const factor = this.maxThrust / totalThrust;

            this.thrust = [thrustX * factor, thrustY * factor];
        }

        calculateVector() {
            Ship.calculateCurrentHeading(this.thrust)
            //console.log([this.vector[0] + this.thrust[0], this.vector[1] + this.thrust[1]])
            return [this.vector[0] + this.thrust[0], this.vector[1] + this.thrust[1]]
        }


        move() {

            this.vector = this.calculateVector()
            this.position[0] += this.vector[0] * 6
            this.position[1] += this.vector[1] * 6

            if(this.targetposition !== this.position) {
                this.setThrustFromHeading(Ship.calculateHeading(this.position, this.targetposition))
            }
        }
    }

    // Ships
    const ships = [
        new Ship("Fleet 1", [(57910000 + 2439 + 600), 0], 60, "blue"),
        new Ship("Fleet 2", [(577910000 + 2439 + 600), -579120], 60, "green"),
        new Ship("Fleet 3", [(227900000 + 3389 - 600), 60000000], 60, "red"),
        new Ship("Fleet 4", [(-27900000 + 3389 - 600), 200000], 60, "yellow"),
        new Ship("Fleet 5", [(579120 + 3389 - 600), -6100000], 60, "orange"),
        new Ship("Fleet 6", [(2439 + 3389 - 600), 60000000], 60, "purple"),
        new Ship("Fleet 7", [(227900000 + 3389 - 600), -10000000], 60, "pink"),
        new Ship("Fleet 8", [(10000000 + 3389 - 600), 12400], 60, "white"),
    ]

    ships[0].thrust = [6, 0]


    function updateUI() {

        document.querySelector('#scale').textContent = Math.round(scale)
        document.querySelector('#timesincestart').textContent = minutesSinceStart
        if (selectedShip) {
            document.querySelector('#shipSelected').textContent = selectedShip.name
            document.querySelector('#shipHeading').textContent = selectedShip.getCurrentHeading() + "Â°" || "0"
            document.querySelector('#shipThrust').textContent = "[" + selectedShip.thrust[0].toFixed(2) + ", " + selectedShip.thrust[1].toFixed(2) + "] | " + selectedShip.maxThrust || "[0, 0]"
        }
    }


    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(offsetX, offsetY);
        ctx.scale(scale, scale);

        // Draw celestial bodies
        bodies.forEach(body => {
            ctx.fillStyle = body.color || 'red';
            ctx.beginPath();
            ctx.arc(body.x / kmPerPixel, body.y / kmPerPixel, body.radius / kmPerPixel, 0, Math.PI * 2);
            ctx.fill();

            // Draw Orbit
            ctx.strokeStyle = "white";
            ctx.lineWidth = 0.5 / scale;
            ctx.beginPath();
            ctx.arc(0, 0, body.x / kmPerPixel, 0, Math.PI * 2);
            ctx.stroke();
        });

        // Draw ships
        ships.forEach(ship => {
            ctx.fillStyle = ship.color;
            ctx.beginPath();
            ctx.rect(ship.position[0] / kmPerPixel, ship.position[1] / kmPerPixel, 50 / scale, 50 / scale);
            ctx.fill();
            // ctx.font = `${20 / scale}px arial`;
            // ctx.fillStyle = "white";
            // ctx.fillText(ship.name, Math.ceil(ship.position[0] / kmPerPixel), Math.ceil(ship.position[1] / kmPerPixel));

            // Draw Ghost Lines and Ranges
            ctx.strokeStyle = "white";
            ctx.lineWidth = 2 / scale;
            ctx.setLineDash([])
            ctx.beginPath();
            ctx.moveTo(ship.position[0] / kmPerPixel, ship.position[1] / kmPerPixel);
            ctx.lineTo(ship.targetposition[0] / kmPerPixel, ship.targetposition[1] / kmPerPixel);
            ctx.stroke();

            if (scale >= 1000) {
                [50000, 25000, 10000, 1250, 10].forEach(range => {
                    const lineDash = range === 10 ? [5 / kmPerPixel, 15 / kmPerPixel] : [500 / kmPerPixel, 1500 / kmPerPixel];
                    ctx.setLineDash(lineDash);
                    ctx.lineWidth = 1 / scale;
                    ctx.beginPath();
                    ctx.arc(ship.position[0] / kmPerPixel, ship.position[1] / kmPerPixel, range / kmPerPixel, 0, Math.PI * 2);
                    ctx.stroke();
                });
            }
        });

        ctx.restore();
    }

    function isNearOrbit(mouseX, mouseY) {
        const orbitClickTolerance = 5;
        const canvasX = (mouseX - offsetX) / scale;
        const canvasY = (mouseY - offsetY) / scale;

        for (let i = 0; i < bodies.length; i++) { // Start from 1 to skip the Sun
            const body = bodies[i];
            const distanceToOrbitCenter = Math.sqrt(canvasX * canvasX + canvasY * canvasY);
            const distanceToOrbit = Math.abs(distanceToOrbitCenter - (body.x / kmPerPixel));

            if (distanceToOrbit <= orbitClickTolerance / scale) {
                // Detected a click near this orbit
                console.log(`Clicked near the orbit of ${body.name}`);
                return body;
            }
        }
        return null;
    }

    function isShip(mouseX, mouseY) {
        const canvasX = (mouseX - offsetX) / scale;
        const canvasY = (mouseY - offsetY) / scale;

        for (let i = 0; i < ships.length; i++) {
            const ship = ships[i];

            if ((canvasX >= ship.position[0] / kmPerPixel && canvasX <= ship.position[0] / kmPerPixel + 50 / scale) && (canvasY >= ship.position[1] / kmPerPixel && canvasY <= ship.position[1] / kmPerPixel + 50 / scale)) {
                return ship;
            }
        }
        return null;
    }

    // Event listener for zooming with mouse scroll
    canvas.addEventListener('wheel', (event) => {
        updateUI()
        event.preventDefault();
        const zoomFactor = 1.1;
        const direction = event.deltaY > 0 ? -1 : 1;
        const mouseX = event.clientX - canvas.offsetLeft;
        const mouseY = event.clientY - canvas.offsetTop;

        // Get the position on the canvas relative to the current zoom and offset
        let worldX = (mouseX - offsetX) / scale;
        let worldY = (mouseY - offsetY) / scale;


        // Adjust scale
        const oldScale = scale;
        scale *= direction > 0 ? zoomFactor : 1 / zoomFactor;
        scale = Math.min(Math.max(scale, 1 / 500000), 10000000); // Limit scale between 1km and 500,000km


        if (selectedShip) {
            // Center zoom on selected ship if one is selected
            const shipX = selectedShip.position[0] / kmPerPixel;
            const shipY = selectedShip.position[1] / kmPerPixel;

            offsetX = (canvas.width / 2) - (shipX * scale);
            offsetY = (canvas.height / 2) - (shipY * scale);

        } else {
            // Adjust offsets to maintain zoom center on cursor position
            offsetX -= (worldX * scale - worldX * oldScale);
            offsetY -= (worldY * scale - worldY * oldScale);
        }

        draw();
    });

    // Variables for dragging
    let isDragging = false;
    let dragStartX, dragStartY;

    // Event listeners for dragging
    canvas.addEventListener('mousedown', (event) => {
        isDragging = true;
        dragStartX = event.clientX;
        dragStartY = event.clientY;
    });

    canvas.addEventListener('mousemove', (event) => {
        if (isDragging) {
            offsetX += (event.clientX - dragStartX);
            offsetY += (event.clientY - dragStartY);
            dragStartX = event.clientX;
            dragStartY = event.clientY;
            draw();
        }
    });

    canvas.addEventListener('mouseup', () => {
        isDragging = false;
    });

    canvas.addEventListener('mouseleave', () => {
        isDragging = false;
    });

    function handleClick(mouseX, mouseY, shiftKey) {
        const body = isNearOrbit(mouseX, mouseY);
        const ship = isShip(mouseX, mouseY);

        if (shiftKey && selectedShip) {
            const canvasMouseX = (mouseX - offsetX) / scale;
            const canvasMouseY = (mouseY - offsetY) / scale;

            selectedShip.targetposition = [canvasMouseX * kmPerPixel, canvasMouseY * kmPerPixel];
            const heading = Ship.calculateHeading(selectedShip.position, selectedShip.targetposition);
            selectedShip.setThrustFromHeading(heading);
        } else if (ship) {
            zoomTo(ship.position[0], ship.position[1], scale);
            selectedShip = ship;
            console.log(`You clicked near the fleet ${ship.name}.`);
        } else if (body) {
            zoomTo(body.x, body.y, body.radius * 5);
            console.log(`You clicked near the orbit of ${body.name}.`);
            selectedShip = null;
        } else {
            selectedShip = null;
        }
    }

    canvas.addEventListener('click', (event) => {
        cmenu = document.querySelector('#contextMenu')
        cmenu.style=`display: none`

        const mouseX = event.clientX - canvas.offsetLeft;
        const mouseY = event.clientY - canvas.offsetTop;
        handleClick(mouseX, mouseY, event.shiftKey);
    });

    canvas.addEventListener('dblclick', (event) => {
        const mouseX = event.clientX - canvas.offsetLeft;
        const mouseY = event.clientY - canvas.offsetTop;
        const ship = isShip(mouseX, mouseY);


        if (ship) {
            zoomTo(ship.position[0], ship.position[1], 5000)
            // Action when an orbit is clicked
            selectedShip = ship
            console.log(`You clicked near the fleet ${ship.name}.`);
        }

    });

    window.addEventListener('keydown', (event) => {
        if (event.key.startsWith('Arrow')) {
            handleArrowKeys(event);
            selectedShip.calculateVector()
            draw()
        }
    });

    canvas.addEventListener('contextmenu', function (event) {
        event.preventDefault();
        //alert("You've tried to open context menu"); //here you draw your own menu
        const mouseX = event.clientX - canvas.offsetLeft;
        const mouseY = event.clientY - canvas.offsetTop;
        const ship = isShip(mouseX, mouseY);

        const canvasMouseX = (mouseX - offsetX) / scale;
        const canvasMouseY = (mouseY - offsetY) / scale;

        targetedPosition = [canvasMouseX * kmPerPixel, canvasMouseY * kmPerPixel];


        cmenu = document.querySelector('#contextMenu')
        cmenu.style=`top: ${event.clientY}px; left: ${event.clientX}px; display: block`

        if (ship) {
            targetedPosition = ship.position
        }
    }, false);

    function setTarget() {
        // Action when an orbit is clicked
        selectedShip.targetposition = targetedPosition
        const t = Ship.calculateHeading(selectedShip.position, selectedShip.targetposition)
        selectedShip.setThrustFromHeading(t)
        console.log(`Setting course to ${targetedPosition}.`);


        cmenu = document.querySelector('#contextMenu')
        cmenu.style=`display: none`
    }

    function handleArrowKeys(event) {
        switch (event.key) {
            case 'ArrowUp':
                selectedShip.thrust[1] -= 1;
                break;
            case 'ArrowDown':
                selectedShip.thrust[1] += 1;
                break;
            case 'ArrowLeft':
                selectedShip.thrust[0] -= 1;
                break;
            case 'ArrowRight':
                selectedShip.thrust[0] += 1;
                break;
        }

        draw();
    }

    // Initial drawing
    draw();

    gameLoop()

    // Resize canvas when the window size changes
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        draw();
    });
</script>
</body>
</html>
