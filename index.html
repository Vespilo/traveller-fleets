<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Solar System Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
            background-color: #000;
        }

        #controlBar {
            position: absolute;
            color: white
        }

        #selectedShip {
            position: absolute;
            top: 50px;
            left: 10px;
            background-color: white;
            padding: 1em;
            min-width: 10em;
        }

        #contextMenu {
            display: none;
            position: absolute;
            padding: 1em;
            background-color: white;
        }
    </style>
</head>
<body>
<nav id="controlBar">
    <span>Current Player: <span id="currentPlayer"></span></span>
    <span>Current Turn: <span id="currentTurn"></span></span>
    <span>Current Phase: <span id="currentPhase"></span></span>
    <span>Time since start: <span id="timesincestart"></span></span>
    <span>Zoom: <span id="scale"></span></span>
    <button onclick="zoomTo(0, 0, 2)">Reset</button>
    <button onclick="endTurn()">Next Phase</button>
</nav>

<div id="selectedShip">
    Selected: <span id="shipSelected"></span><br>
    Vector: <span id="shipHeading"></span><br>
    Target: <span id="shipTarget"></span><br>
    Velocity: <span id="shipVelocity"></span><br>
    Thrust: <span id="shipThrust"></span><br>

    <br>
    <h2>Fleet</h2>
    <ul id="playerFleet">

    </ul>
</div>

<div id="contextMenu">
    <button onclick="document.querySelector('#contextMenu').style = `display: none`">Close</button>
    <div class="contextMenu_movement">
        <span id="targetshipname"></span>
        <button onclick="setTarget()">Target</button>
    </div>
</div>
<div id="text-overlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></div>

<canvas id="solarSystemCanvas"></canvas>

<script>
    const SUB_PHASES = ['Movement', 'Sensors', 'Attacks', 'Damage Control'];
    let needs_redraw = true;
    let needs_ui_update = true;

    let minutesSinceStart = 0
    let selectedShip
    let targetedPosition
    let players = []
    let currentPlayerIndex = 0;
    let currentSubPhaseIndex = 0;
    let ships = []


    const CANVAS = document.getElementById('solarSystemCanvas');
    const CTX = CANVAS.getContext('2d');
    CANVAS.width = window.innerWidth;
    CANVAS.height = window.innerHeight;


    // Initial scale and position
    let scale = 3;
    let offsetX = CANVAS.width / 2;
    let offsetY = CANVAS.height / 2;


    // Conversion factor to fit the celestial bodies on the canvas at the initial scale
    const kmPerPixel = 1000000;

    // Variables for dragging
    let isDragging = false;
    let dragStartX, dragStartY;


    function endTurn() {
        let currentPlayer = players[currentPlayerIndex];

        // Perform actions specific to the current sub-phase
        switch (SUB_PHASES[currentSubPhaseIndex]) {
            case 'Movement':
                currentPlayer.ships.forEach(ship => {
                    ship.move();
                });
                break;
            case 'Sensors':
                // Add sensor logic here
                break;
            case 'Attacks':
                // Add attack logic here
                break;
            case 'Damage Control':
                // Add damage control logic here
                break;
        }

        // Move to the next player or sub-phase
        currentPlayerIndex++;
        if (currentPlayerIndex >= players.length) {
            currentPlayerIndex = 0;
            currentSubPhaseIndex++;
            if (currentSubPhaseIndex >= SUB_PHASES.length) {
                currentSubPhaseIndex = 0;
                console.log('New turn begins.');
            }
        }

        // Update UI for the new player and sub-phase
        needs_ui_update = true;
    }

    function gameLoop() {
        window.requestAnimationFrame(gameLoop);
        if (needs_redraw) {
            draw();
            needs_redraw = false;
        }
        if (needs_ui_update) {
            updateUI();
            needs_ui_update = false;
        }
    }

    function zoomTo(x, y, scaleSize) {
        scale = scaleSize
        offsetX = (CANVAS.width / 2) - (x / kmPerPixel * scale)
        offsetY = (CANVAS.height / 2) - (y / kmPerPixel * scale)
        needs_redraw = true;
    }


    // Celestial bodies data
    const bodies = [
        {name: "Sun", x: 0, y: 0, radius: 696340, color: "yellow"},
        {name: "Mercury", x: 57910000, y: 0, radius: 2439, color: "grey"},
        {name: "Venus", x: 108200000, y: 0, radius: 6051, color: "orange"},
        {name: "Earth", x: 149600000, y: 0, radius: 6371, color: "green"},
        {name: "Mars", x: 227900000, y: 0, radius: 3389, color: "red"},
        {name: "Jupiter", x: 715000000, y: 0, radius: 69911, color: "brown"},
        {name: "Saturn", x: 1433449370, y: 0, radius: 58232, color: "blue"},
        // Add more planets as needed
    ];

    class Util {
        static calculateAngleFromVectors(dx, dy, rounding = 3) {
            /**
             * Returns the angle of two vectors with n decimals
             * @param {number} dx - Delta X
             * @param {number} dy - Delta Y
             * @param {number} rounding - Rounded to n digits
             */
            const angleRadians = Math.atan2(dx, dy);
            const angleDegrees = angleRadians * (180 / Math.PI);
            const x = 10 * rounding
            return Math.round(((angleDegrees + 360) % 360) * x) / x; // Normalize to [0, 360) degrees
        }

        static calculateAngleFromPositions(position_1, position_2, rounding = 3) {
            /**
             * Returns the angle between two positions with n decimals
             * @param {array} position_1 - Position 1
             * @param {array} position_2 - Position 2
             * @param {number} rounding - Rounded to n digits
             */
            const dx = position_2[0] - position_1[0];
            const dy = position_2[1] - position_1[1];
            return Util.calculateAngleFromVectors(dx, dy, rounding);
        }
    }

    class Player {
        constructor(name) {
            this.name = name
            this.ships = []
        }
    }

    class Ship {
        constructor(name, position, thrust, color) {
            this.name = name
            this.position = position
            this.color = color
            this.maxThrust = thrust
            this.heading = 0
            this.vector = [0, 0]
            this.thrust = [0, 0]
            this.targetposition = position
        }


        getCurrentHeading() {
            return Util.calculateAngleFromVectors(this.vector[0], this.vector[1]);
        }


        setThrustFromHeading(angleDegrees) {
            this.heading = angleDegrees;

            // Angle to radians
            const angleRadians = (90 - angleDegrees) * (Math.PI / 180);

            // Calculate thrust angled
            const thrustX = this.maxThrust * Math.cos(angleRadians);
            const thrustY = this.maxThrust * Math.sin(angleRadians);

            // Thrust vector
            const totalThrust = Math.abs(thrustX) + Math.abs(thrustY);
            const factor = this.maxThrust / totalThrust;

            this.thrust = [thrustX * factor, thrustY * factor];
        }

        calculateVector() {
            Util.calculateAngleFromVectors(this.thrust[0], this.thrust[1])
            //console.log([this.vector[0] + this.thrust[0], this.vector[1] + this.thrust[1]])
            return [this.vector[0] + this.thrust[0], this.vector[1] + this.thrust[1]]
        }


        move() {

            this.vector = this.calculateVector()
            this.position[0] += this.vector[0] * 6
            this.position[1] += this.vector[1] * 6

            if (this.targetposition !== this.position) {
                this.setThrustFromHeading(Util.calculateAngleFromPositions(this.position, this.targetposition))
            }
        }
    }

    // Setting Up Default Players
    function initGame() {
        players = [
            new Player("Player 1"),
            new Player("Player 2")
        ]
        players[0].ships = [
            new Ship("Fleet 1", [(57910000 + 2439 + 600), 0], 6, "blue"),
            new Ship("Fleet 2", [(577910000 + 2439 + 600), -579120], 6, "blue"),
            new Ship("Fleet 3", [(227900000 + 3389 - 600), 60000000], 6, "blue"),
            new Ship("Fleet 4", [(-27900000 + 3389 - 600), 200000], 6, "blue"),
        ]
        players[1].ships = [
            new Ship("Fleet 1", [(579120 + 3389 - 600), -6100000], 6, "red"),
            new Ship("Fleet 2", [(2439 + 3389 - 600), 60000000], 6, "red"),
            new Ship("Fleet 3", [(227900000 + 3389 - 600), -10000000], 6, "red"),
            new Ship("Fleet 4", [(10000000 + 3389 - 600), 12400], 6, "red"),
        ]
        ships = [...players[0].ships, ...players[1].ships]
    }

    function updateUI() {
        document.querySelector('#scale').textContent = Math.round(scale);
        document.querySelector('#timesincestart').textContent = minutesSinceStart;
        document.querySelector('#currentPlayer').textContent = players[currentPlayerIndex].name;
        document.querySelector('#currentPhase').textContent = SUB_PHASES[currentSubPhaseIndex];

        //Player Fleet
        const fleetList = document.querySelector('#playerFleet')
        fleetList.innerHTML = ""
        players[currentPlayerIndex].ships.forEach(ship => {
            const listItem = document.createElement('li');
            listItem.textContent = `${ship.name} [${Math.round(ship.position[0])}, ${Math.round(ship.position[1])}]`;
            fleetList.appendChild(listItem);
        });

        if (selectedShip) {
            document.querySelector('#shipSelected').textContent = selectedShip.name;
            document.querySelector('#shipHeading').textContent = selectedShip.getCurrentHeading() + "°" || "0°";
            document.querySelector('#shipThrust').textContent = "[" + selectedShip.thrust[0].toFixed(2) + ", " + selectedShip.thrust[1].toFixed(2) + "] | " + selectedShip.maxThrust || "[0, 0]";
            document.querySelector('#shipTarget').textContent = `[${Math.round(selectedShip.targetposition[0])}, ${Math.round(selectedShip.targetposition[1])}]`;
            document.querySelector('#shipVelocity').textContent = `[${Math.round(selectedShip.vector[0])}, ${Math.round(selectedShip.vector[1])}]`;
        } else {
            document.querySelector('#shipSelected').textContent = "";
            document.querySelector('#shipHeading').textContent = "0";
            document.querySelector('#shipThrust').textContent = "[0, 0]";
        }
    }


    function draw() {
        const textOverlay = document.getElementById('text-overlay');
        textOverlay.innerHTML = '';
        CTX.clearRect(0, 0, CANVAS.width, CANVAS.height);
        CTX.save();
        CTX.translate(offsetX, offsetY);
        CTX.scale(scale, scale);

        const viewX = -offsetX / scale;
        const viewY = -offsetY / scale;
        const viewWidth = CANVAS.width / scale;
        const viewHeight = CANVAS.height / scale;

        // Check if a point (x, y) is within the current view
        function isInView(x, y, radius = 0) {
            return (
                x + radius >= viewX &&
                x - radius <= viewX + viewWidth &&
                y + radius >= viewY &&
                y - radius <= viewY + viewHeight
            );
        }

        // Draw celestial bodies
        bodies.forEach(body => {
            const bodyX = body.x / kmPerPixel;
            const bodyY = body.y / kmPerPixel;
            const bodyRadius = body.radius / kmPerPixel;

            if (isInView(bodyX, bodyY, bodyRadius)) {
                CTX.fillStyle = body.color || 'red';
                CTX.beginPath();
                CTX.arc(bodyX, bodyY, bodyRadius, 0, Math.PI * 2);
                CTX.fill();
            }

            CTX.strokeStyle = "white";
            CTX.lineWidth = 0.5 / scale;
            CTX.beginPath();
            CTX.arc(0, 0, bodyX, 0, Math.PI * 2);
            CTX.stroke();
        });

        // Draw ships
        ships.forEach(ship => {
            const shipX = ship.position[0] / kmPerPixel;
            const shipY = ship.position[1] / kmPerPixel;
            const shipWidth = 25 / scale;
            const shipHeight = 25 / scale;

            if (isInView(shipX, shipY, shipWidth / 2)) {
                CTX.fillStyle = ship.color;
                CTX.beginPath();
                CTX.rect(shipX, shipY, shipWidth, shipHeight);
                CTX.fill();

                // Fleet text
                const textElement = document.createElement('div');
                textElement.textContent = ship.name;
                textElement.style.position = 'absolute';
                textElement.style.left = `${shipX * scale + offsetX}px`;
                textElement.style.top = `${shipY * scale + offsetY}px`;
                textElement.style.color = 'white';
                textElement.style.fontSize = `20px`;
                textElement.style.transform = 'translate(0%, -100%)'; // Center the text
                textOverlay.appendChild(textElement);

                // Draw Ghost Lines and Ranges
                CTX.strokeStyle = "white";
                CTX.lineWidth = 2 / scale;
                CTX.setLineDash([]);
                CTX.beginPath();
                CTX.moveTo(shipX, shipY);
                CTX.lineTo(ship.targetposition[0] / kmPerPixel, ship.targetposition[1] / kmPerPixel);
                CTX.stroke();


                const colors = ['red', 'green', 'pink', 'orange', 'purple'];
                const ranges = [50000, 25000, 10000, 1250, 10];
                ranges.forEach((range, index) => {
                    // Set the color for the current range band
                    CTX.strokeStyle = colors[index] || 'black'; // Default to 'black' if index exceeds colors array length

                    // Set the line dash pattern
                    const lineDash = range === 10 ? [5 / kmPerPixel, 15 / kmPerPixel] : [500 / kmPerPixel, 1500 / kmPerPixel];
                    CTX.setLineDash(lineDash);

                    // Set the line width
                    CTX.lineWidth = scale>20000? Math.floor(1 / scale) : 1 / scale;

                    // Draw the arc
                    CTX.beginPath();
                    CTX.arc(shipX, shipY, range / kmPerPixel, 0, Math.PI * 2);
                    CTX.stroke();
                });
            }
        });

        CTX.restore();
    }

    function objectProximity(mouseX, mouseY) {
        const clickTolerance = 5;
        const canvasX = (mouseX - offsetX) / scale;
        const canvasY = (mouseY - offsetY) / scale;
        let closestObject = null;
        let closestDistance = Infinity;


        // Check for nearest orbit
        for (let i = 0; i < bodies.length; i++) {
            const body = bodies[i];
            const distanceToOrbitCenter = Math.sqrt(canvasX * canvasX + canvasY * canvasY);
            const distanceToOrbit = Math.abs(distanceToOrbitCenter - (body.x / kmPerPixel));

            if (distanceToOrbit <= clickTolerance / scale && distanceToOrbit < closestDistance) {
                closestDistance = distanceToOrbit;
                closestObject = body;
            }
        }

        // Check for nearest ship
        for (let i = 0; i < ships.length; i++) {
            const ship = ships[i];
            const shipX = ship.position[0] / kmPerPixel;
            const shipY = ship.position[1] / kmPerPixel;
            const distanceToShip = Math.sqrt(Math.pow(canvasX - shipX, 2) + Math.pow(canvasY - shipY, 2));

            if (distanceToShip <= clickTolerance / scale) {
                closestDistance = distanceToShip;
                closestObject = ship;
            }
        }

        return closestObject;
    }

    function isNearOrbit(mouseX, mouseY) {
        const orbitClickTolerance = 5;
        const canvasX = (mouseX - offsetX) / scale;
        const canvasY = (mouseY - offsetY) / scale;

        for (let i = 0; i < bodies.length; i++) { // Start from 1 to skip the Sun
            const body = bodies[i];
            const distanceToOrbitCenter = Math.sqrt(canvasX * canvasX + canvasY * canvasY);
            const distanceToOrbit = Math.abs(distanceToOrbitCenter - (body.x / kmPerPixel));

            if (distanceToOrbit <= orbitClickTolerance / scale) {
                // Detected a click near this orbit
                console.log(`Clicked near the orbit of ${body.name}`);
                return body;
            }
        }
        return null;
    }

    function isShip(mouseX, mouseY) {
        const canvasX = (mouseX - offsetX) / scale;
        const canvasY = (mouseY - offsetY) / scale;

        for (let i = 0; i < ships.length; i++) {
            const ship = ships[i];

            if ((canvasX >= ship.position[0] / kmPerPixel && canvasX <= ship.position[0] / kmPerPixel + 50 / scale) && (canvasY >= ship.position[1] / kmPerPixel && canvasY <= ship.position[1] / kmPerPixel + 50 / scale)) {
                return ship;
            }
        }
        return null;
    }

    function handleClick(mouseX, mouseY, shiftKey) {
        const body = isNearOrbit(mouseX, mouseY);
        const ship = isShip(mouseX, mouseY);

        if (ship) {
            selectedShip = ship;
            console.log(`You clicked near the fleet ${ship.name}.`);
            needs_ui_update = true;
        } else if (body) {
            zoomTo(body.x, body.y, body.radius * 5);
            console.log(`You clicked near the orbit of ${body.name}.`);
            selectedShip = null;
            needs_ui_update = true;
        } else {
            selectedShip = null;
            needs_ui_update = true;
        }


        if (shiftKey && selectedShip) {
            if (!players[currentPlayerIndex].ships.includes(selectedShip)) {
                alert("Enemy ship can't be commanded");
                return;
            }
            const canvasMouseX = (mouseX - offsetX) / scale;
            const canvasMouseY = (mouseY - offsetY) / scale;

            selectedShip.targetposition = [canvasMouseX * kmPerPixel, canvasMouseY * kmPerPixel];
            const heading = Util.calculateAngleFromPositions(selectedShip.position, selectedShip.targetposition);
            selectedShip.setThrustFromHeading(heading);
            needs_redraw = true;
        } else if (ship) {
            zoomTo(ship.position[0], ship.position[1], scale);
            selectedShip = ship;
            console.log(`You clicked near the fleet ${ship.name}.`);
            needs_ui_update = true;
        } else if (body) {
            zoomTo(body.x, body.y, body.radius * 5);
            console.log(`You clicked near the orbit of ${body.name}.`);
            selectedShip = null;
            needs_ui_update = true;
        } else {
            selectedShip = null;
            needs_ui_update = true;
        }
    }

    function setTarget() {
        selectedShip.targetposition = targetedPosition
        const t = Util.calculateAngleFromPositions(selectedShip.position, selectedShip.targetposition)
        selectedShip.setThrustFromHeading(t)
        console.log(`Setting course to ${targetedPosition}.`);
        document.querySelector('#contextMenu').style = `display: none`
        needs_ui_update = true
        needs_redraw = true
    }

    // Event listener for zooming with mouse scroll
    CANVAS.addEventListener('wheel', (event) => {
        updateUI()
        event.preventDefault();
        const zoomFactor = 1.1;
        const direction = event.deltaY > 0 ? -1 : 1;
        const mouseX = event.clientX - CANVAS.offsetLeft;
        const mouseY = event.clientY - CANVAS.offsetTop;

        // Get the position on the canvas relative to the current zoom and offset
        let worldX = (mouseX - offsetX) / scale;
        let worldY = (mouseY - offsetY) / scale;


        // Adjust scale
        const oldScale = scale;
        scale *= direction > 0 ? zoomFactor : 1 / zoomFactor;
        scale = Math.min(Math.max(scale, 1 / 500000), 10000000); // Limit scale between 1km and 500,000km


        if (selectedShip) {
            // Center zoom on selected ship if one is selected
            const shipX = selectedShip.position[0] / kmPerPixel;
            const shipY = selectedShip.position[1] / kmPerPixel;

            offsetX = (CANVAS.width / 2) - (shipX * scale);
            offsetY = (CANVAS.height / 2) - (shipY * scale);

        } else {
            // Adjust offsets to maintain zoom center on cursor position
            offsetX -= (worldX * scale - worldX * oldScale);
            offsetY -= (worldY * scale - worldY * oldScale);
        }

        needs_redraw = true;
    });

    // Event listeners for dragging
    CANVAS.addEventListener('mousedown', (event) => {
        isDragging = true;
        dragStartX = event.clientX;
        dragStartY = event.clientY;
    });

    CANVAS.addEventListener('mousemove', (event) => {
        if (isDragging) {
            offsetX += (event.clientX - dragStartX);
            offsetY += (event.clientY - dragStartY);
            dragStartX = event.clientX;
            dragStartY = event.clientY;
            needs_redraw = true;
        }
    });

    CANVAS.addEventListener('mouseup', () => {
        isDragging = false;
    });

    CANVAS.addEventListener('mouseleave', () => {
        isDragging = false;
    });


    CANVAS.addEventListener('click', (event) => {
        document.querySelector('#contextMenu').style = `display: none`

        const mouseX = event.clientX - CANVAS.offsetLeft;
        const mouseY = event.clientY - CANVAS.offsetTop;
        handleClick(mouseX, mouseY, event.shiftKey);
    });

    CANVAS.addEventListener('dblclick', (event) => {
        const mouseX = event.clientX - CANVAS.offsetLeft;
        const mouseY = event.clientY - CANVAS.offsetTop;
        const ship = isShip(mouseX, mouseY);


        if (ship) {
            zoomTo(ship.position[0], ship.position[1], 5000)
            // Action when an orbit is clicked
            selectedShip = ship
            console.log(`You clicked near the fleet ${ship.name}.`);
        }

    });

    CANVAS.addEventListener('contextmenu', function (event) {
        event.preventDefault();
        if (!selectedShip || !players[currentPlayerIndex].ships.includes(selectedShip)) {
            return
        }

        const mouseX = event.clientX - CANVAS.offsetLeft;
        const mouseY = event.clientY - CANVAS.offsetTop;
        const ship = isShip(mouseX, mouseY);
        const body = isNearOrbit(mouseX, mouseY);
        const nearest = objectProximity(mouseX, mouseY)

        const canvasMouseX = (mouseX - offsetX) / scale;
        const canvasMouseY = (mouseY - offsetY) / scale;

        targetedPosition = [canvasMouseX * kmPerPixel, canvasMouseY * kmPerPixel];


        document.querySelector('#contextMenu').style = `top: ${event.clientY}px; left: ${event.clientX}px; display: block`
        const target = document.querySelector('#targetshipname')

        console.log(nearest)

        if (ship) {
            target.textContent = ship.name
            targetedPosition = ship.position
        } else if (body) {
            target.textContent = body.name
            targetedPosition = [body.x, body.y]
        } else {
            target.textContent = "Space"
        }
    }, false);

    window.addEventListener('resize', () => {
        // Resize canvas when the window size changes
        CANVAS.width = window.innerWidth;
        CANVAS.height = window.innerHeight;
        needs_redraw = true;
    });


    // Initial drawing
    initGame()
    gameLoop()
</script>
</body>
</html>
